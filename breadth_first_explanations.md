breadth-first explanations
==========================

someone at my work asked me to explain the programs I had produced in a breadth-first manner. this involves describing the program at a low level of detail, then at progressively higher levels of detail. this has several benefits:
- by repeating each step of the program every time I introduce a deeper level, it commits the information to deeper layers of memory
- if i have to stop explaining the program or the reader/listener gets bored/overwhelmed, something of value has already been communicated. contrast this with a 'depth-first' explanation that exhaustively explains every step in sequence - knowing in detail how the first half of a program works is less useful than having a fuzzy view of the entire process. this is especially valuable in a commercial context where people are often pressed for time, don't care personally about what is going on and are already juggling a number of other plates
- it's possible to "zoom in" on particular parts of the program while also seeing how they fit into the overall process
- this method of explaining does not make any assumptions about the particular part of the program the reader/listener may be interested in
- a program structure that is easy to explain in this way is also easy to understand by a developer who wishes to modify/understand the source code itself

the above argument does not only apply to computer programs (this is just the domain that i am most experienced with). you can and should also take this approach when explaining:
- scientific theories
- historical events
- recipes and other algorithms/processes such as musical pieces
